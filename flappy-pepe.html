<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>PEPEGAME – Flappy Pepe</title>
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f9fafb;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 12px 8px 24px;
      text-align: center;
    }

    h1 {
      font-size: 20px;
      margin: 4px 0 2px;
    }
    #subtitle {
      font-size: 12px;
      opacity: 0.85;
      margin-bottom: 8px;
    }

    #game-wrapper {
      width: 100%;
      max-width: 420px;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(15, 23, 42, 0.9);
      background: #0f172a;
      margin-bottom: 8px;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: auto;
      background: #000;
    }

    #hud {
      margin-top: 4px;
      font-size: 13px;
    }

    #score {
      font-size: 18px;
      font-weight: 600;
    }

    #best {
      font-size: 11px;
      opacity: 0.8;
    }

    #hint {
      font-size: 11px;
      opacity: 0.9;
      margin-top: 6px;
    }

    #back-link {
      margin-top: 10px;
      font-size: 13px;
      text-decoration: none;
      color: #a5b4fc;
    }
  </style>
</head>
<body>
  <h1>PEPEGAME – Flappy Pepe</h1>
  <div id="subtitle">Tape l’écran pour faire voler Pepe et éviter les tuyaux (décor qui évolue avec ton run).</div>

  <div id="game-wrapper">
    <canvas id="gameCanvas" width="300" height="450"></canvas>
  </div>

  <div id="hud">
    <div>Score : <span id="score">0</span></div>
    <div id="best">Meilleur score local : <span id="bestScore">0</span></div>
    <div id="hint">Touchez pour sauter · Collision = reset.</div>
  </div>

  <a id="back-link" href="index.html">⬅ Retour au Hub</a>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const bestScoreEl = document.getElementById('bestScore');

    // --- Meilleur score local ---
    function loadBestScore() {
      const v = localStorage.getItem('flappyBestScore');
      return v ? parseInt(v, 10) : 0;
    }
    function saveBestScore(v) {
      localStorage.setItem('flappyBestScore', String(v));
    }

    let bestScore = loadBestScore();
    bestScoreEl.textContent = bestScore;

    // --- Paramètres de jeu (easy au début) [web:181][web:214] ---
    let gravity = 0.32;
    let flapStrength = -7;
    let pipeGap = 140;
    let pipeWidth = 55;
    let pipeSpeed = 1.7;

    let birdX = 70;
    let birdY = canvas.height / 2;
    let birdVy = 0;
    const birdRadius = 14;

    let pipes = [];
    let score = 0;
    let gameOver = false;
    let started = false;

    // --- Distance & décor évolutif ---
    let distance = 0;
    let distancePerFrame = 1;

    let currentStage = 1;           // décor actuellement "fixé"
    let targetStage = 1;            // décor visé selon la distance
    let lastStage = 1;              // décor précédent (pour fondu)
    let stageTransitionProgress = 1; // 0 -> 1 (fondu terminé)

    // Charge les 4 backgrounds avec TES noms de fichiers
    const bgImages = [];

    // 1 = grenouille pauvre
    bgImages[1] = new Image();
    bgImages[1].src = 'image-9.png';

    // 2 = un peu mieux habillée
    bgImages[2] = new Image();
    bgImages[2].src = 'image-10.png';

    // 3 = plus riche
    bgImages[3] = new Image();
    bgImages[3].src = 'image-19.png';

    // 4 = très riche
    bgImages[4] = new Image();
    bgImages[4].src = 'image-15.png';

    function resetGame() {
      birdX = 70;
      birdY = canvas.height / 2;
      birdVy = 0;
      pipes = [];
      score = 0;
      gameOver = false;
      started = false;
      scoreEl.textContent = score;

      // Reset difficulté
      gravity = 0.32;
      pipeGap = 140;
      pipeSpeed = 1.7;

      // Reset distance & décor
      distance = 0;
      currentStage = 1;
      targetStage = 1;
      lastStage = 1;
      stageTransitionProgress = 1;
    }

    function createPipe() {
      const minHeight = 40;
      const maxHeight = canvas.height - pipeGap - 80;
      const topHeight = Math.floor(Math.random() * (maxHeight - minHeight)) + minHeight;

      pipes.push({
        x: canvas.width + 20,
        top: topHeight,
        passed: false
      });
    }

    let frameCount = 0;

    function update() {
      if (!started) return;

      // Distance parcourue (sert à faire évoluer le décor) [web:193]
      distance += distancePerFrame;

      // Détermine la targetStage selon la distance (paliers à ajuster si besoin)
      let newTarget = 1;
      if (distance >= 800 && distance < 2000) {
        newTarget = 2;
      } else if (distance >= 2000 && distance < 4000) {
        newTarget = 3;
      } else if (distance >= 4000) {
        newTarget = 4;
      }

      if (newTarget !== targetStage) {
        lastStage = currentStage;
        targetStage = newTarget;
        stageTransitionProgress = 0; // lance un nouveau fondu
      }

      // Avancement du fondu crescendo (0.01 ~ 2 s, à ajuster) [web:189]
      if (stageTransitionProgress < 1) {
        stageTransitionProgress += 0.01;
        if (stageTransitionProgress >= 1) {
          stageTransitionProgress = 1;
          currentStage = targetStage;
        }
      }

      // Physique de l'oiseau
      birdVy += gravity;
      birdY += birdVy;

      frameCount++;
      if (frameCount % 90 === 0) {
        createPipe();
      }

      for (let i = pipes.length - 1; i >= 0; i--) {
        const p = pipes[i];
        p.x -= pipeSpeed;

        // Passage réussi → +1 score & scaling difficulté [web:171][web:181]
        if (!p.passed && p.x + pipeWidth < birdX) {
          p.passed = true;
          score++;
          scoreEl.textContent = score;
          if (score > bestScore) {
            bestScore = score;
            bestScoreEl.textContent = bestScore;
            saveBestScore(bestScore);
          }

          if (score === 5) {
            pipeGap = 130;
            pipeSpeed = 1.9;
          } else if (score === 10) {
            pipeGap = 120;
            pipeSpeed = 2.1;
          } else if (score === 20) {
            pipeGap = 110;
            pipeSpeed = 2.4;
          }
        }

        if (p.x + pipeWidth < -10) {
          pipes.splice(i, 1);
        }
      }

      // Collision haut / bas
      if (birdY + birdRadius >= canvas.height || birdY - birdRadius <= 0) {
        gameOver = true;
      }

      // Collisions avec les tuyaux
      for (const p of pipes) {
        const inX = birdX + birdRadius > p.x && birdX - birdRadius < p.x + pipeWidth;
        const inYTop = birdY - birdRadius < p.top;
        const inYBottom = birdY + birdRadius > p.top + pipeGap;
        if (inX && (inYTop || inYBottom)) {
          gameOver = true;
        }
      }

      if (gameOver) {
        started = false;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // --- Dessin du décor avec fondu crescendo ---
      const bgCurrent = bgImages[currentStage];
      const bgTarget = bgImages[targetStage];

      if (bgCurrent && bgCurrent.complete && stageTransitionProgress === 1) {
        // Pas de transition : décor courant
        ctx.drawImage(bgCurrent, 0, 0, canvas.width, canvas.height);
      } else if (bgCurrent && bgCurrent.complete && bgTarget && bgTarget.complete) {
        // Transition : fondu croisé entre lastStage et targetStage [web:189][web:193]
        const alpha = stageTransitionProgress;

        ctx.globalAlpha = 1 - alpha;
        ctx.drawImage(bgImages[lastStage], 0, 0, canvas.width, canvas.height);

        ctx.globalAlpha = alpha;
        ctx.drawImage(bgTarget, 0, 0, canvas.width, canvas.height);

        ctx.globalAlpha = 1;
      } else {
        // Fallback si les images ne sont pas encore chargées
        const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, '#0ea5e9');
        grd.addColorStop(0.7, '#22c55e');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // Sol
      ctx.fillStyle = '#16a34a';
      ctx.fillRect(0, canvas.height - 60, canvas.width, 60);

      // Tuyaux
      ctx.fillStyle = '#0f172a';
      for (const p of pipes) {
        ctx.fillRect(p.x, 0, pipeWidth, p.top);
        ctx.fillRect(
          p.x,
          p.top + pipeGap,
          pipeWidth,
          canvas.height - (p.top + pipeGap)
        );
      }

      // Pepe (cercle vert pour le proto)
      ctx.beginPath();
      ctx.arc(birdX, birdY, birdRadius, 0, Math.PI * 2);
      ctx.fillStyle = '#22c55e';
      ctx.fill();
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#022c22';
      ctx.stroke();

      ctx.fillStyle = '#0f172a';
      ctx.beginPath();
      ctx.arc(birdX + 4, birdY - 4, 3, 0, Math.PI * 2);
      ctx.fill();

      if (!started && !gameOver) {
        ctx.fillStyle = 'rgba(15,23,42,0.8)';
        ctx.font = '16px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Touchez pour commencer', canvas.width / 2, canvas.height / 2 - 12);
      }

      if (gameOver) {
        ctx.fillStyle = 'rgba(15,23,42,0.75)';
        ctx.fillRect(30, canvas.height / 2 - 40, canvas.width - 60, 80);
        ctx.fillStyle = '#f9fafb';
        ctx.font = '16px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Game over', canvas.width / 2, canvas.height / 2 - 10);
        ctx.font = '13px system-ui';
        ctx.fillText('Touchez pour rejouer', canvas.width / 2, canvas.height / 2 + 14);
      }
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    function flap() {
      if (gameOver) {
        resetGame();
        return;
      }
      started = true;
      birdVy = flapStrength;
    }

    canvas.addEventListener('click', flap);
    canvas.addEventListener('touchstart', function(e) {
      e.preventDefault();
      flap();
    }, { passive: false });

    resetGame();
    loop();
  </script>
</body>
</html>
